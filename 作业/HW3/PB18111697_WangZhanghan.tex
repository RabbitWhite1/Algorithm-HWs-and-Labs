\documentclass[UTF8]{article}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{makecell}
\usepackage[utf8]{inputenc}
\usepackage[space]{ctex} %中文包
\usepackage{listings} %放代码
\usepackage{xcolor} %代码着色宏包
\usepackage{CJK} %显示中文宏包
\usepackage{float}
\usepackage{diagbox}
\usepackage{bm}
\usepackage{ulem} 
\usepackage{amssymb}
\usepackage{soul}
\usepackage{color}
\usepackage{geometry}
\usepackage{fancybox} %花里胡哨的盒子
\usepackage{xhfill} %填充包, 可画分割线 https://www.latexstudio.net/archives/8245
\usepackage{multicol} %多栏包
\usepackage{enumerate} %可以方便地自定义枚举标题
\usepackage{multirow} %表格中多行单元格合并
\usepackage{wasysym} %可以使用wasysym里的一堆奇奇怪怪的符号
\usepackage{hyperref} % url
%%%%%%%%%%%%%%%伪代码%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%%%%%%%%%%%%%%%画图包%%%%%%%%%%%%%%%
\usepackage{tikz}
\usepackage{pgfplots} % http://pgfplots.sourceforge.net/gallery.html
\usetikzlibrary{pgfplots.patchplots} % 拟合支持
\usetikzlibrary{arrows,shapes,automata,petri,positioning,calc} % 状态图支持
\usetikzlibrary{arrows.meta} % 箭头
\usetikzlibrary{shadows} % 阴影支持
\usepackage{forest} % 画树

\geometry{left = 1.5cm, right = 1.5cm, top=1.5cm, bottom=2cm}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
	backgroundcolor=\color{white}, 
	%\tiny < \scriptsize < \footnotesize < \small < \normalsize < \large < \Large < \LARGE < \huge < \Huge
	basicstyle = \footnotesize,       
	breakatwhitespace = false,        
	breaklines = true,                 
	captionpos = b,                    
	commentstyle = \color{mygreen}\bfseries,
	extendedchars = false,
	frame = shadowbox, 
	framerule=0.5pt,
	keepspaces=true,
	keywordstyle=\color{blue}\bfseries, % keyword style
	language = C++,                     % the language of code
	otherkeywords={string}, 
	numbers=left, 
	numbersep=5pt,
	numberstyle=\tiny\color{mygray},
	rulecolor=\color{black},         
	showspaces=false,  
	showstringspaces=false, 
	showtabs=false,    
	stepnumber=1,         
	stringstyle=\color{mymauve},        % string literal style
	tabsize=4,          
	title=\lstname           
}

%\sum\nolimits_{j=1}^{M}   上下标位于求和符号的水平右端，
%\sum\limits_{j=1}^{M}   上下标位于求和符号的上下处，
%\sum_{j=1}^{M}  对上下标位置没有设定，会随公式所处环境自动调整。

%%%%%%%%%%%%%画图包%%%%%%%%%%%%%
\usepackage{tikz}
%%%%%%%%%%%%%好看的矩形%%%%%%%%%%%%%
\tikzset{
	rect1/.style = {
		shape = rectangle,% 指定样式
		minimum height=2cm,% 最小高度
		minimum width=4cm,% 最小宽度
		align = center,% 文字居中
		drop shadow,% 阴影
	}
}
%%%%%%%%%%%%%画图背景包%%%%%%%%%%%%%
\usetikzlibrary{backgrounds}

%%%%%%%%%%%%%在tikz中画一个顶点%%%%%%%%%%%%%
%%%%%%%%%%%%%#1:node名称%%%%%%%%%%%%%
%%%%%%%%%%%%%#2:位置%%%%%%%%%%%%%
%%%%%%%%%%%%%#3:标签%%%%%%%%%%%%%
\newcommand{\newVertex}[3]{\node[circle, draw=black, line width=1pt, scale=0.8] (#1) at #2{#3}}
%%%%%%%%%%%%%在tikz中画一条边%%%%%%%%%%%%%
\newcommand{\newEdge}[2]{\draw [black,very thick](#1)--(#2)}
%%%%%%%%%%%%%在tikz中放一个标签%%%%%%%%%%%%%
%%%%%%%%%%%%%#1:名称%%%%%%%%%%%%%
%%%%%%%%%%%%%#2:位置%%%%%%%%%%%%%
%%%%%%%%%%%%%#3:标签内容%%%%%%%%%%%%%
\newcommand{\newLabel}[3]{\node[line width=1pt] (#1) at #2{#3}}

%%%%%%%%%%%%%强制跳过一行%%%%%%%%%%%%%
\newcommand{\jumpLine} {\hspace*{\fill} \par}
%%%%%%%%%%%%%关键点指令,可用itemise替代%%%%%%%%%%%%%
\newcommand{\keypoint}[2]{$\bullet$\textbf{#1}\quad#2\par}
%%%%%%%%%%%%%<T>平均值表示%%%%%%%%%%%%%
\newcommand{\average}[1]{\left\langle #1\right\rangle }
%%%%%%%%%%%%%表格内嵌套表格%%%%%%%%%%%%%
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
%%%%%%%%%%%%%大黑点item头%%%%%%%%%%%%%
\newcommand{\itemblt}{\item[$\bullet$]}
%%%%%%%%%%%%%大圈item头%%%%%%%%%%%%%
\newcommand{\itemc}{\item[$\circ$]}
%%%%%%%%%%%%%大星星item头%%%%%%%%%%%%%
\newcommand{\itembs}{\item[$\bigstar$]}
%%%%%%%%%%%%%右▷item头%%%%%%%%%%%%%
\newcommand{\itemrhd}{\item[$\rhd$]}
%%%%%%%%%%%%%定义为%%%%%%%%%%%%%
\newcommand{\defas}{=_{df}}
%%%%%%%%%%%%%偏导%%%%%%%%%%%%%
\newcommand{\partialx}[2]{\frac{\partial #1}{\partial #2}}
%%%%%%%%%%%%%蕴含%%%%%%%%%%%%%
\newcommand{\imp}{\rightarrow}
%%%%%%%%%%%%%上取整%%%%%%%%%%%%%
\newcommand{\ceil}[1]{\lceil#1\rceil}
%%%%%%%%%%%%%下取整%%%%%%%%%%%%%
\newcommand{\floor}[1]{\lfloor#1\rfloor}

%%%%%%%%%%%%%双线分割线%%%%%%%%%%%%%
\newcommand*{\doublerule}{\hrule width \hsize height 1pt \kern 0.5mm \hrule width \hsize height 2pt}
%%%%%%%%%%%%%双线中间可加东西的分割线%%%%%%%%%%%%%
\newcommand\doublerulefill{\leavevmode\leaders\vbox{\hrule width .1pt\kern1pt\hrule}\hfill\kern0pt }
%%%%%%%%%%%%%左大括号%%%%%%%%%%%%%
\newcommand{\leftbig}[1]{\left\{\begin{array}{l}#1\end{array}\right.}
%%%%%%%%%%%%%矩阵%%%%%%%%%%%%%
\newcommand{\mat}[2]{\left[\begin{array}{#1}#2\end{array}\right]}
%%%%%%%%%%%%%可换行圆角文本框%%%%%%%%%%%%%
\newcommand{\ovalboxn}[1]{\ovalbox{\tabincell{l}{#1}}}
%%%%%%%%%%%%%设置section的counter, 使从1开始%%%%%%%%%%%%%
\setcounter{section}{0}

%%%%%%%%%%%%%Colors%%%%%%%%%%%%%
\newcommand{\lightercolor}[3]{% Reference Color, Percentage, New Color Name
	\colorlet{#3}{#1!#2!white}
}
\newcommand{\darkercolor}[3]{% Reference Color, Percentage, New Color Name
	\colorlet{#3}{#1!#2!black}
}
\definecolor{aquamarine}{rgb}{0.5, 1.0, 0.83}
\definecolor{Seashell}{RGB}{255, 245, 238} %背景色浅一点的
\definecolor{Firebrick4}{RGB}{255, 0, 0}%文字颜色红一点的
\lightercolor{gray}{20}{lgray}
\newcommand{\hlg}[1]{
	\begingroup
	\sethlcolor{lgray}%背景色
	\textcolor{black}{\hl{\mbox{#1}}}%textcolor里面对应文字颜色
	\endgroup
}

\title{算法基础 HW3}
\author{PB18111697 王章瀚}

\begin{document}
\maketitle
\section{}
\noindent 下面的排序算法中哪些是稳定的：插入排序、归并排序、堆排序、快速排序和计数排序？给出一个能使任何排序算法都稳定的方法。你所给出的方法带来的额外时间和空间开销是多少？

\begin{itemize}
	\item 稳定的排序算法有: 插入排序, 归并排序, 计数排序\footnote{参考网站(助教就当没看见哈\smiley):\url{https://www.cnblogs.com/Leophen/p/11397731.html}}(但其实真的需要所有的都可以稳定的...)
	\item 使任何排序算法都稳定的方法: \\
	只需要将需要排序的元素对象封装为一个数据结构, 这个数据结构包含这个元素以及一个元素原本的次序。这样，在做排序的时候，优先按照元素排序，若相同，就按照这个次序域的值排序（要求按原本次序），即可完成稳定的排序。\\
	下面是一个通用的示例程序，以方便助教理解我的意思：
	\begin{lstlisting}[language=c++]
template <class T>
class Element {
public:
	T elem;
	int order;
	
	Element(T elem, int order): elem(elem), order(order) {};
	bool operator< (const Element &e) {
		if (this->elem < e.elem) return true;
		else if(this->elem == e.elem) return (this->order < e.order);
		else return false;
	}
	// 其它运算符也做类似重载
}\end{lstlisting}
	\item 这种方法带来额外时间开销只是需要多比较一个order, 而空间开销则是$\Theta(n)$的(为$n$个元素各加了1个order域)
\end{itemize}

\newpage
\section{}
\noindent 假设用 {\sc Random-Selecet} 去选择数组 $A=<3,2,9,0,7,5,4,8,6,1>$的最小元素, 给出能够导致 {\sc Random-Selecet} 最坏情况的一个划分序列.\\

\noindent 可以每次都选择最大元素, 那么就会有这样的最坏划分序列:
\begin{center}
\begin{forest}
	[{$<3,2,9,0,7,5,4,8,6,1>$}
		[{$<3,2,0,7,5,4,8,6,1>$}	
			[{$<3,2,0,7,5,4,6,1>$}
				[{$<3,2,0,5,4,6,1>$}
					[{$<3,2,0,5,4,1>$}
						[{$<3,2,0,4,1>$}
							[{$<3,2,0,1>$}
								[{$<2,0,1>$}
									[{$<0,1>$}
										[{$<0>$}]
										[{$<1>$}]
									]
									[{$<2>$}]
								]
								[{$<3>$}]
							]
							[{$<4>$}]
						]
						[{$<5>$}]
					]
					[{$<6>$}]
				]
				[{$<7>$}]
			]
			[{$<8>$}]
		]
		[{$<9>$}]
	];
\end{forest}
\end{center}

\section{}
\noindent 因为在基于比较的排序模型中, 完成$n$个元素的排序, 其最坏情况下需要$\Omega(n\lg n)$时间. 试证明: 任何基于比较的算法从$n$个元素的任意序列中构造一棵二叉搜索树, 其最坏情况下需要$\Omega(n\lg n)$的时间.\\

\noindent \textbf{反证}假设: 如果构造一棵二叉搜索树, 最坏情况下不需要这么多($\Omega(n\lg n)$)的时间, \\
那么, 我们可以直接构造一棵二叉搜索树, 然后经过一次中序遍历($\Theta(n)$)就能得到排序好的数组, \\
这时, 总的时间必然是少于$\Omega(n\lg n)$的, \\
这与"\underline{在基于比较的排序模型中, 完成$n$个元素的排序, 其最坏情况下需要$\Omega(n\lg n)$时间}"相矛盾.\\
因此命题成立.
\hfill$\square$

\newpage
\section{}
\noindent 证明: 在一棵高度为$h$的二叉搜索树上, 无论从哪个结点开始, $k$次连续的{\sc Tree-Successor} 调用所需时间为$O(k+h)$.\\

\noindent 无论从哪个结点开始, 从访问第一个到访问第$k$个, 其间至多有$2h$个结点是访问了但无效的(不是要找的后继的结点), 这$2h$个结点来自
\begin{itemize}
	\item 刚开始需要从比较靠近叶子的结点不断向上直到不再是右结点, 才能得到后继, 这里最多$h$个
	\item 快结束了需要从靠近根处往下, 寻找右子树的最小元, 从根节点到此最小元这里最多需要$h$个
\end{itemize}
此外, 剩下的都是对有用节点的访问, 这里每个结点最多被访问到3次(当有左右子节点的时候), 因此这里最多是$3k$次的访问.\\
综上, 总共最多访问$2h+3k<3(h+k)$次结点, 所以可以认为题述情况所需时间为$O(k+h)$


\end{document}









